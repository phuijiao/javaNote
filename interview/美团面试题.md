# 一 基础篇

## 1 `System.out.println(3|9)`输出什么？

按位或。3 | 9=0011（二进制） | 1001（二进制）=1011（二进制）=11（十进制）

**&和&&：**

- **共同点：**两者都可以做逻辑运算符。它们都表示运算符的两边都是true时，结果为true。

- **不同点：**&也是位运算符。&表示在运算时两边都会计算，然后再判断；&&表示先运算符号左边的东西，然后判断是否为true，是true就继续运算右边的然后判断输出，是false就停下来直接输出不会再运行后面到的东西。

**| 和 ||：**

- **共同点：**两者都可做逻辑运算符。它们都表示运算符的两边任意一边为true，结果为true，两边都不是true，结果就位false。
- **不同点：**| 也是位运算符。|表示两边都会运算，然后再判断结果；||表示先运算符号左边的东西，然后判断是否为true，是true就停下来直接输出不会再运行后面的东西，是false就继续运算右边的然后判断并输出。



## 2 说一下转发(Forward)和重定向(Redirect)的区别

**转发是服务器的行为，重定向是客户端的行为。**
**转发**通过RequestDispatcher对象的forward()方法实现。RequestDispacher可以通过HttpServletRequest的getRequestDispatcher()方法获得。

**重定向**是利用服务器返回的状态码来实现的。客户端浏览器请求服务器的时候，服务器返回一个状态码。如果服务器返回301或者302，则浏览器会到新的网址重新请求该资源。

1. **从地址栏显示来说：**forward是服务器请求资源，服务器直接访问目标地址的URL，把那个URL的响应内容读取过来，然后把这些内容再发给浏览器。浏览器根本不知道服务器发送的的内容从哪里来的，所以它的地址栏还是原来的地址。redirect是服务器端根据逻辑，发送一个状态码，告诉浏览器重新去请求那个地址。所以浏览器地址栏显示的是新的URL。
2. **从数据共享来说：**forware转发页面和转发到的页面可以共享request里面的数据。redirect不能共享数据。
3. **从运用地方来说：**forward一般用于用户登录的时候，根据角色转发到相应的模块。redirect一般用于用户注销登录时返回主页面和跳转到其它的网站等。
4. **从效率来说：**forward 高，redirect 低。



## 3 在浏览器中输入url地址到显示主页的过程，整个过程会用到哪些协议？

![各种网络请求用到的协议](.assets\各种网络请求用到的协议.jpg)

总的来说分为以下几个过程：

1. DNS解析
2. TCP连接
3. 发送HTTP请求
4. 服务器处理请求并返回HTTP报文
5. 浏览器解析渲染页面
6. 连接结束



## 4 TCP三次握手和四次挥手

<img src=".assets\tcp三次握手2.jpg" alt="img" style="zoom: 25%;" />

- 客户端 - 发送带有SYN标志的数据包 - 一次握手 - 服务端
- 服务端 - 发送带有SYN/ACK标志的数据包 - 二次握手 - 客户端
- 客户端 - 发送带有ACK标志的数据包 - 三次握手 - 服务端



**为什么要三次握手？**

**三次握手的目的是建立可靠的通信信道，说到通信，简单来说就是数据的发送与接收，而三次握手最主要的目的就是双发确认自己与对方的发送与接收是正常的。**



**为什么要传回SYN?**

接收端传回发送端所发的SYN是为了告诉发送端，我接收的信息确实就是你所发的信号了。

> SYN是TCP/IP建立连接是使用的握手信号。在客户机和服务器之间建立正常的TCP网络连接时，客户机首先发出一个SYN消息，服务器使用SYN-ACK应答表示接受到了这个消息，最后客户机再以ACK消息响应。这样在客户机和服务器之间才能建立起可靠的TCP连接，数据才可以在客户机和服务器之间传递。



**传了SYN为什么还要穿ACK？**

双方通信无误必须是两者互相发送信息都无误。传了SYN，证明发送方到接收方的信道没有问题，但是接收方到发送方的通道还需要ACK信号来进行验证。



**断开一个TCP连接需要四次挥手：**

- 客户端 - 发送一个FIN，用来关闭客户端到服务器的数据传送。
- 服务器 - 收到这个FIN，它发回一个ACK，确认序号为收到的序号加1。和SYN一样，一个FIN将占用一个序号。
- 服务器 - 关闭与客户端的连接，发送一个FIN给客户端。
- 客户端 - 发回ACK报文确认，并将确认序号设置为收到序号加1。



**为什么要四次挥手？**

任何一方都可以在数据传输结束后发出连接释放的通知，待对方确认后进入半关闭状态。当另一方也没有数据再发送的时候，则发出连接释放通知，对方确认后就完全关闭了TCP连接。



## 5 IP地址与MAC地址的区别

IP地址是指互联网协议地址（Internet Protocol Address）。IP地址是IP协议提供的一种统一的地址格式，它为互联网上的每一个网络和每一台主机分配一个逻辑地址，以此来屏蔽物理地址的差异。

MAC地址又称为物理地址、硬件地址，用来定义网络设备的位置。网卡的物理地址通常是由网卡生产厂家写入网卡的，具有全球唯一性。MAC地址用于在网络中唯一标示一个网卡，一台电脑会有一个或多个网卡，每个网卡都需要有一个唯一的MAC地址。



## 6 HTTP请求、响应报文格式

HTTP请求报文主要由请求行、请求头部、请求正文3部分组成。

HTTP响应报文主要由状态行、响应头部、响应正文3部分组成。



## 7 索引

**7.1 为什么要使用索引？**

1. 通过创建唯一性索引，可以保证数据库表中每一行数据的唯一性。
2. 可以大大加快数据的检索速度（大大减少的索引的数据量），这也是创建索引的最主要的原因。
3. 帮助服务器避免排序和临时表。
4. 将随机IO变为顺序IO。
5. 可以加速表和表之间的连接，特别是实现数据的参考完整性方面特别有意义。



**7.2 索引这么多优点，为什么不对表中的每一个列创建一个索引呢？**

1. 当对表中的数据进行增加、删除和修改的时候，索引也要动态的维护，这样就降低了数据的维护速度。
2. 索引需要占用物理空间，除了数据表占用空间之外，每一个索引还要占用一定的物理空间，如果要建立聚簇索引，那么需要的空间就会更大。
3. 创建索引和维护索引要耗费时间，这种时间随着数据量的增加而增加。



**7.3 索引是如何提高查询速度的？**

将无序的数据变成相对有序的数据（就像查目录一样）。



**7.4 使用索引的注意事项？**

1. 避免where子句中对字段施加函数，这会造成无法命中索引。
2. 在使用InnoDB时，使用与业务无关的自增主键作为主键，即使用逻辑主键，而不要使用业务主键。
3. 将打算加索引的列建议设置为NOT NULL，因为NULL比空字符串需要更多的存储空间（不仅仅是索引列，普通列如果业务允许都建议设置为NOT NULL）。
4. 删除长期未使用的索引，不用的索引的存在会造成不必要的性能损耗。
5. 在使用limit offset查询缓慢时，可以借助索引来提高性能。



**7.5 Mysql索引主要使用的哪两种数据结构？**

- 哈希索引：对于哈希索引来说，底层的数据结构就是哈希表，因此在绝大多数需求为单条记录查询的时候，可以选择哈希索引，查询性能最快；其余大部分场景，建议选择BTree索引。
- BTree索引：Mysql的BTree索引使用的是B树中的B+Tree。但对于主要的两种存储引擎（MyISAM和InnoDB）的实现方式是不同的。



**7.6 什么是覆盖索引？**

如果一个索引包含（或者说覆盖）所有要查询的字段的值，我们就称之为“覆盖索引”。我们知道在InnoDB存储引擎中，如果不是主键索引，叶子节点存储的是主键+列值，最终还是要“回表”，也就是要通过主键再查询一次，这样就会比较慢。覆盖索引就是把要查询出的列和索引是对应的，不做回表操作。



## 8 进程与线程

**8.1 进程与线程的区别是什么？**

线程与进程相似，但线程是一个比进程更小的执行单位。一个进程在其执行的过程中可以产生多个线程。与进程不同的是同类的多个线程共享同一块内存空间和一组系统资源，所以系统在产生一个线程，或是在各个线程之间做切换工作时，负担要比进程小得多，也正因为如此，线程也被称为轻量级进程。另外，也正因为共享资源，所以线程中执行时一般都要进行同步和互斥。总的来说，进程和线程的主要差别在于它们是不同的操作系统资源管理方式。



**8.2 进程间的几种通信方式说一下？**

1. **管道（pipe）：**管道是一种半双工的通信方式，数据只能单向流动，而且只能在具有血缘关系的进程间使用。进程的血缘关系通常指父子进程关系。管道分为pipe（无名管道）和fifo（命名管道）两种，命名管道也是半双工的通信方式，但是它允许无亲缘关系进程间通信。
2. **信号量（semophore）：**信号量是一个计数器，可以用来控制多个进程对共享资源的访问。它通常作为一种锁机制，防止某进程正在访问共享资源时，其它进程也访问该资源。因此，主要作为进程间以及同一进程内不同线程之间的同步手段。
3. **消息队列（message queue）:**消息队列是由消息组成的链表，存放在内核中，并由消息队列标识符标示。消息队列克服了信号量传递信息少，管道只能承载无格式字节流以及缓冲区大小受限等缺点。消息队列与管道相比，其优势是对每个消息指定特定的消息类型，接收的时候不需要按照队列次序，而是可以根据自定义接收特定类型的消息。
4. **信号（signal）：**信号是一种比较复杂的通信方式，用于通知接收进程某一事件已经发生。
5. **共享内存（shared memory）：**共享内存就是映射一段能被其它进程所访问的内存，这段共享内存由一个线程创建，但多个进程都可以访问，共享内存是最快的IPC方式（进程间通信 Inter Process Communication），它是针对其它进程间的通信方式运行效率低而专门设计的。它往往与其它通信机制，如信号量配合使用，来实现进程间的同步和通信。
6. **套接字（socket）：**socket，即套接字是一种通信机制，凭借这种机制，客户端/服务器（即要进行通信的进程）系统的开发工作既可以在本地单机上进行，也可以跨网络进行。也就是说它可以让不在同一台计算机但通过网络连接的计算机上的进程进行通信。也因为这样，套接字明确地将客户端和服务器区分开来。



**8.3 线程间有几种通信方式？**

1. 锁机制
   - 互斥锁：提供了以排它方式阻止数据结构被并发修改的方法。
   - 读写锁：允许多个线程同时读取共享数据，而对写操作互斥。
   - 条件变量：可以以原子的方式阻塞进程，直到某个条件为真为止。对条件测试是在互斥锁的保护下进行的。条件变量始终与互斥锁一起使用。
2. 信号量机制：包括无名信号量与有名信号量。
3. 信号机制：类似于进程间的信号处理。

线程间通信的主要目的是用于线程同步，所以线程没有像进程通信中用于数据交换的通信机制。



## 9 为什么要用单例模式？

**单例模式的好处：**

- 对于频繁使用的对象，可以省略创建对象所花费的时间，这对于那些重量级对象而言，是非常可观的一笔系统开销。
- 由于new操作的次数减少，因而对系统内存的使用频率也会降低，这将减轻GC压力，缩短GC停顿时间。



## 10 简单介绍一下bean；知道Spring的bean的作用域和生命周期吗？

在Spring中，那些组成应用程序的主体及由Spring IOC容器所管理的对象，被称之为bean。简单地讲，**bean就是由IOC容器初始化、装配及管理的对象**，除此之外，bean就与应用程序中的其它对象没有什么区别了。而bean的定义以及bean相互间的依赖关系通过配置元数据来描述。

Spring中的bean默认都是单例的；Spring的单例是基于BeanFactory也就是Spring容器的，单例Bean在此容器内只有一个，Java的单例是基于JVM的，每个JVM内只有一个实例。



**bean的作用域**

1. **singleton -- 唯一bean实例。**当一个bean的作用域为singleton，那么Spring IOC容器中只会存在一个共享的bean实例，并且所有对bean的请求，只要id与该bean定义相匹配，则只会返回bean的同一实例。在创建起容器时就同时自动创建了一个bean对象，但可以延迟到第一次请求该bean时才初始化。
2. **prototype -- 每次请求都会创建一个新的bean实例。**当一个bean的作用域为prototype，表示一个bean定义对应多个对象实例。prototype是原型类型，它在我们创建容器的时候并没有实例化，而是当我们获取bean的时候才会去创建一个对象，每次请求都会创建一个新的bean实例。有状态的bean应该使用prototype作用域，而对无状态的bean则应该使用singleton作用域。
3. **request -- 每次HTTP请求都会产生一个新的bean，该bean仅在当前HTTP request内有效。**request只适用于web程序，每一次HTTP请求都会产生一个新的bean，同时该bean仅在当前HTTP request内有效，当请求结束后，该对象的生命周期即告结束。
4. **session -- 每一次HTTP请求都会产生一个新的bean，该bean仅在当前HTTP session内有效。**session只适用于web程序，当HTTP session最终被废弃的时候，在该HTTP session作用域内的bean也会被废弃掉。
5. **globalSession**仅在基于portlet的web应用中才有意义。



**bean的生命周期**

- Bean容器找到配置文件中Spring Bean的定义。
- Bean容器利用Java Reflection API创建一个Bean的实例。
- 如果涉及到一些属性值，利用set方法设置一些属性值。
- 如果Bean实现了BeanNameAware接口，调用setBeanName()方法，传入Bean的名字。
- 如果Bean实现了BeanClassLoaderAware接口，调用setBeanClassLoader()方法，传入ClassLoader对象的实例。
- 如果Bean实现了BeanFactoryAware接口，调用setBeanFactory(BeanFactory)方法，传递的是Spring工厂自身。
- 与上面的类似，如果实现了其它*Aware接口，就调用相应的方法。
- 如果有和加载这个Bean的Spring容器相关的BeanPostProcessor对象，执行postProcessBeforeInitialization()方法。
- 如果Bean实现了InitializingBean接口，执行afterPropertiesSet()方法。
- 如果Bean在配置文件中 的定义包含init-method属性，执行指定的方法。
- 如果有和加载这个Bean的Spring容器相关的BeanPostProcessor对象，执行postProcessAfterInitialization()方法。
- 当要销毁Bean的时候，如果Bean实现了DisposableBean接口，执行destroy()方法。
- 当要销毁Bean的时候，如果Bean在配置文件中的定义包含destroy-method属性，执行指定的方法。



## 11 Spring中的事务

**11.1 事务传播行为**

事务传播行为（为了解决事务方法之间相互调用的事务问题）：当事务方法被另一个事务方法调用时，必须指定事务应该如何传播。例如：方法可能继续在现有事务中运行，也可能开启一个新事务，并且在自己的事务中运行。在TransactionDefinition中包括了如下几个表示传播行为的常量：

**支持当前事务的情况：**

- PROPAGATION_REQUIRED:如果当前存在事务，则加入该事务；如果当前没有事务，则创建一个新的事务。
- PROPAGATION_SUPPORTS:如果当前存在事务，则加入该事务；如果当前没有事务，则以非事务的方式继续运行。
- PROPAGATION_MANDATORY:如果当前存在事务，则加入该事务；如果当前没有事务，则抛出异常。

**不支持当前事务的情况：**

- PROPAGATION_REQUIRES_NEW：创建一个新的事务，如果当前存在事务，则把当前事务挂起。
- PROPAGATION_NOT_SUPPORTED：以非事务方式运行，如果当前存在事务，则把当前事务挂起。
- PROPAGATION_NEVER：以非事务方式运行，如果当前存在事务，则抛出异常。

**其它情况：**

- PROPAGATION_NESTED：如果当前存在事务，则创建一个事务作为当前事务的嵌套事务来运行；如果当前没有事务，则该取值等价于PROPAGATION_REQUITED。



**11.2 隔离级别**

TransactionDefinition接口中定义了五个表示隔离级别的常量：

- ISOLATION_DEFAULT：使用后端数据库默认的隔离级别，Mysql默认采用的REPEATABLE_READ隔离级别；Oracle默认采用的READ_COMMITTED隔离级别。
- ISOLATION_READ_UNCOMMITED：最低的隔离级别，允许读取尚未提交的数据变更，可能会导致脏读、幻读或不可重复读。
- ISOLATION_READ_COMMITTED：允许读取并发事务已经提交的数据，可以阻止脏读，但是幻读或不可重复读仍有可能发生。
- ISOLATION_REPEATABLE_READ：对同一字段的多次读取结果都是一致的，除非数据是被本身事务自己所修改，可以阻止脏读和不可重复读，但幻读仍有可能发生。
- ISOLATION_RERIALIZABLE：最高隔离级别，完全服从ACID的隔离级别。所有的事务依次逐个执行，这样事物之间就完全不可能产生干扰，该级别可以防止脏读、不可重复读以及幻读。但是这将严重影响程序的性能。通常情况下也不会用到该级别。



## SpringMVC原理了解吗？

客户端发送请求 --> 前端控制器DispatchServlet接收客户端请求 --> 找到处理器映射器HandlerMapping解析请求对应的Handler --> HandlerAdapter会根据Handler来调用真正的处理器处理请求，并处理相应的业务逻辑 --> 处理器返回一个模型视图ModelAndView --> 视图解析器进行解析 --> 返回一个视图对象 -->前端控制器DispatchServlet渲染数据（Model） -->将得到视图对象返回给用户



## 13 SpringMVC AOP IOC实现原理

**IOC:**控制反转也叫依赖注入。IOC利用Java反射机制，AOP利用代理模式。IOC就是将对象交个容器管理，只需要在Spring配置文件中配置对应的bean以及设置相关的属性，让Spring容器来生成类的实例对象以及管理对象。在Spring容器启动的时候，Spring会把在配置文件中配置的bean都初始化好，然后在需要调用的时候，就把它已经初始化好的那些bean分配给你需要调用这些bean的类。

**AOP:**面向切面编程。AOP可以说是对OOP的补充和完善。OOP引入封装、继承和多态性等概念来建立一种对象层次结构，用以模拟公共行为的一个集合。实现AOP的技术，主要分为两大类：一是采用动态代理技术，利用截取消息的方式，对该消息进行装饰，以取代原有对象行为的执行；二是采用静态织入的方式，引入特定的语法创建“方面”，从而使得编译器可以在编译期间织入有关“方面”的代码，属于静态代理。



# 二 进阶篇

## 1 消息队列MQ的套路

**1.1 消息队列MQ的应用场景/使用消息队列的好处**

**1） 通过异步处理提高系统性能**

![通过异步处理提高系统性能](.assets\通过异步处理提高系统性能.jpg)

在不使用消息队列服务器的时候，用户的请求数据直接写入数据库，在高并发的情况下数据库压力剧增，使得响应速度变慢。但是在使用消息队列之后，用户的请求数据发送给消息队列之后立即返回，再由消息队列的消费者进程从消息队列中获取数据，异步写入数据库。由于消息队列服务器处理速度快于数据库（消息队列也比数据库有更好的伸缩性），因此响应速度得到大幅改善。

消息队列具有很好的削峰作用	 -- 即通过异步处理，将短时间高并发产生的事务消息存储在消息队列中，从而削平高峰期的并发事务。



**2） 降低系统耦合性**

模块分布式部署以后聚合方式通常有两种：**1. 分布式消息队列**和 **2.分布式服务**。

目前使用比较多的用来构建SOA（Service Oriented Architecture 面向服务体系结构）的分布式服务框架是阿里巴巴开源的 **Dubbo**。

如果模块之间不存在直接调用，那么新增模块或者修改模块就对其它模块影响较小，这样系统的可扩展性会更好一些。

我们最常见的事件驱动架构类似生产者消费者模式，在大型网站中通常利用消息队列实现事件驱动结构。

![利用消息队列实现事件驱动结构](.assets\利用消息队列实现事件驱动结构.jpg)

消息队列使用发布-订阅模式工作，消息发送者（生产者）发布消息，一个或多个消息接受者（消费者）订阅消息。从上图可以看到消息发送者（生产者）和消息接受者（消费者）之间没有直接耦合，消息发送者将消息发送至分布式消息队列即结束对消息的处理，消息接受者从分布式消息队列获取该消息后进行后续处理，并不需要知道消息从何而来。对新增业务，只要对该消息感兴趣，即可订阅消息，对原有系统和业务没有任何影响，从而实现网站业务的扩展性设计。

为了避免消息队列服务器宕机造成消息丢失，会将成功发送到消息队列的消息存储在消息生产者服务器上，等消息真正被消费者服务器处理后才删除消息。在消息队列服务器宕机后，生产者服务器会选择分布式消息队列服务器集群中的其他服务器发布消息。



**1.2 使用消息队列会带来什么问题？**

- **系统可用性降低：**在加入MQ之前，不用考虑消息丢失或者说MQ挂掉等等情况，但是，引入MQ之后就需要考虑了。
- **系统复杂性提高：**加入MQ之后，需要保证消息没有被重复消费、处理消息丢失情况、保证消息传递的顺序性等问题。
- **一致性问题：**消息队列可以实现异步，消息队列带来的异步确实可以提高系统响应速度。但是万一消息的真正消费者并没有正确消费消息怎么办？这样就会导致数据不一致的情况了。



**1.3 介绍一下几种消息队列，该如何选择？**

| 特性                    | ActiveMQ                                                     | RabbitMQ                                                     | RocketMQ                                                     | Kafka                                                        |
| ----------------------- | ------------------------------------------------------------ | ------------------------------------------------------------ | ------------------------------------------------------------ | ------------------------------------------------------------ |
| 单机吞吐量              | 万级                                                         | 万级                                                         | 10万级                                                       | 10万级，一般配合大数据类的系统来进行实时数据计算、日志采集等场景 |
| topic数量对吞吐量的影响 |                                                              |                                                              | topic可以达到几百、几千个的级别，吞吐量会有较小幅度的下降。优势：在同等机器下，可以支撑大量的topic | topic从几十个到几百个的时候，吞吐量会有大幅度下降。所以在同等机器下，kafka尽量保证topic数量不要过多。如果要支撑大规模topic，需要增加更多的机器资源 |
| 可用性                  | 高，基于主从架构实现高可用                                   | 高，基于主从架构实现高可用                                   | 非常高，分布式架构                                           | 非常高，kafka是分布式的，一个数据多个副本，少数机器宕机，不会丢失数据，不会导致不可用 |
| 消息可靠性              | 有较低的概率丢失数据                                         |                                                              | 经过参数优化配置，可以做到0丢失                              | 经过参数优化配置，可以做到0丢失                              |
| 时效性                  | ms级                                                         | us级，这是rabbitMQ的一大特点，延迟是最低的                   | ms级                                                         | 延迟在ms级以内                                               |
| 功能支持                | MQ领域的功能及其完备                                         | 基于erlang开发，所以并发性能很强，性能及其好，延时很低       | MQ功能较为完善，还是分布式的，扩展性好                       | 功能较为简单，主要支持简单的MQ功能，在大数据领域的实时计算以及日志采集中被大规模使用，是事实上的标准 |
| 优势劣势                | 非常成熟，功能强大，在业务大量的公司以及项目中都有应用。偶尔会有较低概率丢失消息，而且现在社区以及国内应用都越来越少，官方社区现在对ActiveMQ 5.x维护越来越少。主要是基于解耦和异步来用的，较少在大规模吞吐的场景中使用 | erlang语言开发，性能及其好，延时很低；吞吐量到万级，MQ功能比较完备而且开源提供的管理界面非常棒，用起来很好用。社区相对比较活跃，几乎每个月都发布几个版本。RabbitMQ确实吞吐量会低一些，这是因为它的实现机制比较重。而且erlang源码难懂。集群动态扩展会麻烦 | 接口简单易用，在阿里大规模应用过。日处理消息上百亿之多，可以做到大规模吞吐，性能也非常好，分布式扩展也很方便，社区维护还可以，可靠性和可用性都很好，还可以支持大规模的topic数量，支持复杂MQ业务场景。是Java系的，我们可以自己阅读源码，定制知己公司的MQ，可以掌控。社区活跃度相对较为一般，文档相对简单一些，接口不是标准JMS规范，有些系统要迁移需要修改大量代码。 | kafka仅仅提供较少的核心功能，但是提供超高的吞吐量，ms级的延迟，超高的可用性和可靠性，而且分布式可以任意扩展。同时kafka最好是支撑较少的topic数量即可，保证其超高吞吐量。而且kafka唯一的一点劣势是有可能消息重复消费，那么对数据准确性会造成极其轻微的影响，在大数据领域中以及日志采集中，这点轻微影响可以忽略，这个特性天然适合大数据实时计算以及日志收集 |



## 2 谈谈InnoDB和MyIsam两者的区别

**2.1 **两者事务对比

1. **count运算上的区别：**因为MyISAM缓存有表mete-data（行数等），因此在做COUNT(*)时对于一个结构很好的查询是不需要消耗多少资源的。而对于InnoDB来说，则没有这种缓存。
2. **是否支持事务和崩溃后的安全恢复：**MyISAN强调的是性能，每次查询都具有原子性，其执行速度比InnoDB类型更快，但是不提供事务支持。InnoDB提供事务支持、外部键等高级数据库功能。具有事务提交（commit）、回滚（rollback）、和崩溃修复能力（crash recovery capabilities）的事务安全型表。
3. **是否支持外键：**MyISAM不支持，而InnoDB支持。



**2.2 关于两者的总结**

MyISAM更适合读密集的表，而InnoDB更适合写密集的表。在数据库做主从分离的情况下，经常选择MyISAM作为主库的存储引擎。

一般来说，如果需要事务支持，并且有较高的并发读取频率（MyISAM的表锁的粒度太大，所以当该表写并发量较高时，要等待的查询就会很多了），InnoDB是不错的选择。如果你的数据量很大（MyISAM支持压缩特性，可以减少磁盘的空间占用），而且不需要支持事务时，MuISAM时最好的选择。



## 3 Java中的集合

**3.1 ArrayList与LinkedList有什么不同？（注意加上从数据结构分析的内容）**

1. **是否保证线程安全：**ArrayList和LinkedList都是不同步的，也就是都不保证线程安全；
2. **底层数据结构：**ArrayList底层使用的是Object数组；LinkedList底层使用的是双向链表结构；
3. **插入和删除元素是否受元素位置的影响：** ①ArrayList采用数组存储，所以插入和删除元素的时间复杂度受元素位置的影响。②LiinkedList采用链表存储，所以插入、删除元素复杂度不受元素位置的影响，都近似O(1)，而数组为近似O(n)。
4. **是否支持快速随机访问：**LinkedList不支持高效的随机元素访问，而ArrayList支持。快速随机访问就是通过元素的序号快速获取元素对象。
5. **内存空间占用：**ArrayList的空间浪费主要在list列表的结尾会预留一定容量空间，而LinkedList的空间花费则在它的每个元素都需要消耗比ArrayList更多的空间（因为要存放直接后继和直接前驱以及数据）。



> **RandomAccess接口**
>
> 查看源码我们发现实际上RandomAccess接口中什么都没有定义。所以，在我看来RandomAccess接口不过是一个标识罢了。标识实现这个接口的类具有随机访问功能。
>
> 在binarySearch()方法中，要判断传入的list是否是RandomAccess的实例，如果是，调用indexedBinarySearch()方法，如果不是，那么调用iteratorBinaruSearch()方法。

ArrayList实现了RandomAccess接口，而LinkedList没有实现。

ArrayList底层是数组，而LinkedList底层是链表。数组天然支持随机访问，而且复杂度为O(1)，所以称为快速随机访问。链表需要遍历到特定位置才能访问特定位置的元素，时间复杂度为O(n)，所以不支持快速随机访问。

ArrayList实现了RandomAccess接口，就表明了它具有快速随机访问的功能。RandomAccess接口只是标识，并不是说ArrayList实现RandomAccess接口才具有快速随机访问功能的。



**下面再总结一下list的遍历方式选择：**

- 实现了RandomAccess接口的list，优先选择普通for循环，其次foreach。
- 未实现RandomAccess接口的list，优先选择iterator遍历（foreach遍历底层也是通过iterator实现的），大size的数据，千万不要使用普通for循环



**3.2 HashMap的底层实现**

**1）JKD1.8之前**

JDK1.8之前HashMap底层是数组和链表结合在一起使用的，也就是链表散列。HashMap通过`(n-1)&hash`判断当前元素存放的位置（这里n指的是数组的长度），如果当前位置存在元素的话，就判断该元素与要存入的元素的hash值以及key是否相同，如果相同的话，直接覆盖，不相同就通过拉链法解决冲突。

所谓**扰动函数**指的是HashMap的hash方法。使用扰动函数是为了防止一些实现比较差的hashCode()方法，使用扰动函数之后可以减少碰撞。

所谓**拉链法**就是：将链表和数组相结合。也就是创建一个链表数组，数组中每一格就是一个链表。若遇到哈希冲突，则将冲突的值加到链表中即可。



**2）JDK1.8及之后**

当链表长度大于阈值（默认为8）时，将链表转化为红黑树，以减少搜索时间。

![jdk1.8之后的内部结构-HashMap](.assets\JDK1.8之后的HashMap底层数据结构.jpg)

TreeMap、TreeSet以及JDK1.8之后的HashMap底层都用到了红黑树。红黑树就是为了解决二叉查找树的缺陷，因为二叉查找树在某些情况下会退化成一个线性结构。



**3.3 红黑树的特点**

![红黑树](.assets\红黑树.png)

1. 每个节点非红即黑；
2. 根节点总是黑色的；
3. 每个叶子节点都是黑色的空节点（NIL节点）；
4. 如果节点是红色的，则它的子节点必须是黑色的（反之不一定）；
5. 从根节点到叶子节点或空节点的每条路径，必须包含相同数目的黑色节点（即相同的黑色高度）；



**3.4 红黑树这么优秀，为何不直接使用红黑树得了？**

红黑树属于（自）平衡二叉树，为了保持平衡是需要付出代价的，红黑树在插入新数据后可能需要通过左旋、右旋、变色这些操作来保持平衡。引入红黑树是为了查找数据快，但如果链表很短的话，根本不需要引入红黑树，引入之后就要付出维持它的平衡的代价。但是链表过长就不一样了。至于为什么选8这个值呢？通过概率统计所得，这个值是综合查询成本和新增元素成本得出的最好的一个值。



**3.5 HashMap和Hashtable的区别**

1. **线程是否安全：**HashMap是非线程安全的，Hashtable是线程安全的；Hashtable内部的方法基本都经过`synchronized`修饰。（如果想要保证线程安全的话就使用ConcurrentHashMap吧）。
2. **效率：**因为线程安全的问题，HashMap要比Hashtable效率高一点。另外，Hashtable基本被淘汰，不要在代码中使用它。
3. **对Null key和Null value的支持：**HashMap中，null可以作为键，这样的键只有一个，可以有一个或多个键所对应的值为null。但是在Hashtable中put进的键值只要有一个null，直接抛出NullPointerException。
4. **初始容量大小和每次扩充容量大小的不同：**①创建时如果不指定容量初始值，Hashtable默认的初始大小为11，之后每次扩充，容量变为原来的`2n+1`。HashMap默认的初始化大小为16，之后每次扩充，容量变为原来的2倍。②创建时如果给定了容量初始值，那么Hashtable会直接使用给定的大小，而HashMap会将其扩充为2的幂次方大小。也就是说HashMap总是使用2的幂作为哈希表的大小。
5. **底层数据结构：**JDK1.8以后的HashMap在解决哈希冲突时有了较大的变化，当链表长度大于阈值（默认为8）时，将链表转化为红黑树，以减少搜索时间。Hashtable没有这样的机制。



**3.6 HashSet和HashMap的区别**

HashSet底层是基于HashMap实现的。（HashSet的源码非常少，因为除了clone()方法、writeObject()方法、readObject()方法是HashSet自己不得不实现之外，其它方法都是直接调用HashMap中的方法。）



# 三 终结篇

## 1 Object类有哪些方法？

**Object类常见方法总结**

```java
public final native Class<?> getClass()//native方法，用于返回当前运行时对象的Class对象，使用了final关键字修饰，故不允许子类重写。

public native int hashCode() //native方法，用于返回对象的哈希码，主要使用在哈希表中，比如JDK中的HashMap。
public boolean equals(Object obj)//用于比较2个对象的内存地址是否相等，String类对该方法进行了重写用户比较字符串的值是否相等。

protected native Object clone() throws CloneNotSupportedException//naitive方法，用于创建并返回当前对象的一份拷贝。一般情况下，对于任何对象 x，表达式 x.clone() != x 为true，x.clone().getClass() == x.getClass() 为true。Object本身没有实现Cloneable接口，所以不重写clone方法并且进行调用的话会发生CloneNotSupportedException异常。

public String toString()//返回类的名字@实例的哈希码的16进制的字符串。建议Object所有的子类都重写这个方法。

public final native void notify()//native方法，并且不能重写。唤醒一个在此对象监视器上等待的线程(监视器相当于就是锁的概念)。如果有多个线程在等待只会任意唤醒一个。

public final native void notifyAll()//native方法，并且不能重写。跟notify一样，唯一的区别就是会唤醒在此对象监视器上等待的所有线程，而不是一个线程。

public final native void wait(long timeout) throws InterruptedException//native方法，并且不能重写。暂停线程的执行。注意：sleep方法没有释放锁，而wait方法释放了锁 。timeout是等待时间。

public final void wait(long timeout, int nanos) throws InterruptedException//多了nanos参数，这个参数表示额外时间（以毫微秒为单位，范围是 0-999999）。 所以超时的时间还需要加上nanos毫秒。

public final void wait() throws InterruptedException//跟之前的2个wait方法一样，只不过该方法一直等待，没有超时时间这个概念

protected void finalize() throws Throwable { }//实例被垃圾回收器回收的时候触发的操作
```



## 2 ConcurrentHashMap相关问题

**2.1 ConcurrentHashMap和Hashtable的区别**

ConcurrentHashMap和Hastable的区别主要体现在实现线程安全的方式上不同。

- **底层数据结构：**JDK1.7的ConcurrentHashMap底层采用**分段的数组+链表**实现，JDK1.8采用的数据结构跟HashMap1.8的结构一样，数组+链表/红黑树。Hashtable和JDK1.8之前的HashMap的底层数据结构类似，都采用**数组+链表**的形式，数组是HashMap的主体，链表则是主要为了解决哈希冲突而存在的。
- **实现线程安全的方式：**①**在JDK1.7的时候，ConcurrentHashMap（分段锁）**对整个桶数组进行了分割分段（Segment），每一把锁只锁容器其中一部分数据，多线程访问容器里不同数据段的数据，就不会存在锁竞争，提高并发访问率。（默认分配16个Segment，比Hashtable效率提高16倍）。**到了JDK1.8的时候，已经摒弃了Segment的概念，而是直接用Node数组+链表+红黑树的数据结构来实现，并发控制使用synchronized和CAS（cas是compareandswap，比较并更新）来操作。（JDK1.6以后对synchronized锁做了很多优化）**整个看起来就像是优化过且线程安全的HashMap。② **Hashtable（同一把锁）：**使用synchronized来保证线程安全，效率非常低下。当一个线程访问同步方法时，其它线程也访问同步方法，可能会进入阻塞或轮询状态，如使用put添加元素，另一个线程不能使用put添加元素，也不能使用get，竞争会越来越激烈，效率低下。

![img](.assets\50656681.jpg)

JDK1.7 的 ConcurrentHashMap：

![img](.assets\33120488.jpg)

JDK1.8 的 ConcurrentHashMap（TreeBin: 红黑二叉树节点 Node: 链表节点）：

![img](.assets\97739220.jpg)



**2.2 ConcurrentHashMap线程安全的具体实现方式/底层具体实现**

**JDK1.7:**

首先将数据分为一段一段的存储，然后给每一段数据配置一把锁，当一个线程占用锁访问其中一个数据时，其它段的数据也能被其它线程访问。

**ConcurrentHashMap是由Segment数组结构和HashEntry数组结构组成。**

Segment实现了ReentrantLock，所以Segment是一种可重入锁，扮演锁的角色。HashEntry用于存储键值对数据。

一个ConcurrentHashMap里包含一个Segment数组。Segment的结构和HashMap类似，是一种数组和链表结构，一个Segment包含一个HashEntry数组，每个HashEntry是一个链表结构的元素，每个Segment守护着一个HashEntry数组里的元素，当对HashEntry数组的数据进行修改时，必须首先获得对应的Segment的锁。



**JDK1.8:**

ConcurrentHashMap取消了Segment分段锁，采用CAS和synchronized来保证并发安全。数据结构跟HashMap1.8的结构类似，Node数组+链表/红黑二叉树。

synchronized只锁定当前链表或红黑二叉树的首节点，这样只要hash不冲突，就不会产生并发，效率有提升N倍。



## 3 谈谈synchronized和ReentrantLock的区别

1. **两者都是可重入锁**

   “可重入锁”概念是：自己可以再次获取自己的内部锁。比如一个线程获得了某个对象的锁，此时这个对象锁还没有释放，当其再次想要获取这个对象的锁的时候还是可以获取的，如果锁不可重入的话，就会造成死锁。同一个线程每次获取锁，锁的计数器都自增1，所以要等到锁的计数器下降为0时才能释放锁。
   
2. **synchronized依赖于JVM而ReentrantLock依赖于API**

   synchronized是依赖于JVM实现的，虚拟机团队在JDK1.6为synchronized关键字进行了很多优化，但是这些优化都是在虚拟机层面实现的，并没有直接暴露给我们。ReentrantLock是JDK层面实现的（也就是API层面，需要lock()和unlock()方法配合try/finally语句块来完成），所以我们可以通过查看它的源码，来看它是如何实现的。

3. **ReentrantLock比synchronized增加了一些高级功能**

   主要有三点：**①等待可中断；②可实现公平锁③可实现选择性通知（锁可以绑定多个条件）**

   - **ReentrantLock提供了一种能够中断等待锁的机制**，通过lock.lockInterruptibly()来实现这个机制。也就是说正在等待的线程可以选择放弃等待，改为处理其他事情。
   - **ReentrantLock可以指定是公平锁还是非公平锁。而synchronized只能是非公平锁。所谓的公平锁就是先等待的线程先获得锁。**ReentrantLock默认情况是非公平的，可以通过ReentrantLock类的 `ReentrantLock(boolean fair)`构造函数来指定是否是公平的。
   - synchronized关键字与wait()和notify()/notifyAll()方法相结合可以实现等待/通知机制,ReentrantLock类当然也可以实现，但是需要借助于Condition接口与newCondition()方法。Condition是JDK1.5之后才有的，它具有很好的灵活性，比如可以实现多路通知功能，也就是在一个Lock对象中可以创建多个Condition实例（即对象监视器），**线程对象可以注册在指定的Condition中，从而可以有选择性的进行线程通知，在调度线程上更加灵活。在使用notify/notifyAll()方法进行通知时，被通知的线程是由JVM选择的，用ReentrantLock类结合Condition实例可以实现“选择性通知”**，这个功能非常重要，而且是Condition接口默认提供的。而synchronized关键字就相当于整个Lock对象中只有一个Condition实例，所有的线程都注册在它一个身上。如果执行notifyAll()方法的话就会通知所有处于等待状态的线程这样会造成很大的效率问题，而Condition实例的signalAll()方法只会唤醒注册在该Condition实例中的所有线程。
   
4. **两者的性能已经相差无几**

在JDK1.6之前，synchronized的性能是比ReentrantLock差的多。具体表现为：synchronized关键字吞吐量随线程数的增加，下降得非常严重。而ReentrantLock基本保持一个比较稳定的水平。在JKD1.6之后JVM团队对synchronized关键字做了很多优化。JDK1.6之后，synchronized和ReentrantLock的性能基本是持平了。而且虚拟机在未来的性能改进中会偏向于原生的synchronized。



## 4 线程池

**4.1 为什么要用线程池？**

线程池提供了一种限制和管理资源（包括执行一个任务）。每个线程池还维护一些基本统计信息，例如已完成任务的数量。

线程池的好处：

- **降低资源消耗。**通过重复利用已创建的线程降低线程创建和销毁造成的消耗。
- **提高响应速度。**当任务到达时，任务可以不需要等到线程创建就能立即执行。
- **提高线程的可管理性。**线程是稀缺资源，如果无限制的创建，不仅会消耗系统资源，还会降低系统的稳定性，使用线程池可以进行统一的分配，调优和监控。



**4.2 Java提供了哪几种线程池？它们各自的使用场景是什么？**

**Java主要提供了下面4种线程池**

- **FixedThreadPool:**该方法返回一个固定线程数量的线程池。该线程池中的线程数量始终不变。当有新的任务提交时，线程池中若有空闲线程，则立即执行。若没有，则新的任务会被暂存在一个任务队列中，待有线程空闲时，便处理在任务队列中的的任务。
- **SingleThreadExecutor:**方法返回一个只有一个线程的线程池。若多于一个任务被提交到该线程池，任务会被保存在一个任务队列中，待线程空闲，按先入先出的顺序执行队列中的任务。
- **CachedThreadPool:**该方法返回一个可根据实际情况调整线程数量的线程池。线程池的线程数量不确定，但若有空闲线程可以复用，则会优先使用可复用的线程。若所有线程均在工作，又有新的任务提交，则会创建新的线程处理任务。所有线程在当前任务执行完毕后，将返回线程池进行复用。
- **ScheduledThreadPoolExecutor:**主要用来在给定的延迟后运行任务，或者定期执行任务。ScheduledThreadPoolExecutor又分为：ScheduledThreadPoolExecutor（包含多个线程）和SingleThreadScheduledExecutor（只包含一个线程）两种。



**各种线程池的适用场景介绍**

- **FixedThreadPool:**适用于为了满足资源管理需要，而需要限制当前线程数量的应用场景。它适用于负载比较重的服务器。
- **SingleThreadExecutor:**适用于需要保证顺序地执行各个任务并且在任意时间点，不会有多个线程是活动的应用场景。
- **CachedThreadPool:**适用于执行很多的短期异步任务的小程序，或者是负载较轻的服务器。
- **ScheduledThreadPoolExecutor:**适用于需要多个后台线程执行周期任务，同时为了满足资源管理需要而需要限制后台线程的数量的应用场景。 
- **SinglethreadScheduledExecutor:**适用于需要单个后台线程执行周期任务，同时保证顺序地执行各个任务的应用场景。



 **4.3 创建线程池的方式**

1. **使用Executors创建。**
2. **ThreadPoolExecutor的构造函数创建。**这种情况下，一旦提交的线程数超过当前可用线程数时，就会抛出异常，这是因为当前线程池使用的队列是有边界队列，队列已经满了便无法继续处理新的请求。
3. **使用开源类库。**推荐使用guava提供的ThreadFactoryBuilder来创建线程池。



## 5 Nginx

**5.1 简单介绍一下Nginx**

Nginx是一款轻量级的web服务器/反向代理服务器及电子邮件(IMAP/POP3)代理服务器。Nginx主要提供反向代理、负载均衡、动静分离（静态资源服务）等服务。



**反向代理**

无论是正向代理还是反向代理，都是代理模式的衍生版本罢了。

- **正向代理：**某些情况下，代理我们用户去访问服务器，需要用户手动的设置代理服务器的ip和端口号。正向代理比较常见的一个例子就是VPN了。
- **反向代理：**是用来代理服务器的，代理我们要访问的目标服务器。代理服务器接收请求，然后将请求转发给内部网络的服务器，并将从服务器上得到的结果返回给客户端，此时代理服务器对外就表现为一个服务器。



**负载均衡**

在高并发情况下需要使用，其原理就是将并发请求分摊到多个服务器执行，减轻每台服务器的压力，多台服务器（集群）共同完成工作任务，从而提高了数据的吞吐量。

Nginx支持weight轮询（默认）、ip_hash、fair、url_hash这四种负载均衡调度算法。

负载均衡相比于反向代理更侧重的是将请求分担到多台服务器上去，所以谈论负载均衡只有在提供某服务的服务器大于两台时才有意义。



**动静分离**

动静分离是让动态网站里的动态网页根据一定规则把不变的资源和经常变的资源分开来，动静资源做好了拆分以后，我们就可以根据静态资源的特点将其做缓存操作，这就是网站静态化处理的核心思路。



**5.2 为什么要用Nginx？**

Nginx有一下5个优点：

1. 高并发、高性能（这是其他web服务器不具备的）。
2. 可扩展性好（模块化设计，第三方插件生态圈丰富）。
3. 高可用性（可以在服务器中持续不间断的运行数年）。
4. 热部署（热部署指可以在不停止Nginx服务的情况下升级Nginx）。
5. BSD许可证（意味着我们可以将源码下载下来进行修改后使用自己的版本）。



**5.3 Nginx的四个主要组成部分**

- Nginx二进制可执行文件：由各模块源码编译出一个文件。
- nginx.conf配置文件：控制Nginx行为。
- access.log访问日志：记录每一条Http请求信息。
- error.log错误日志：定位问题。